<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Nix recipes for Haskellers - Sridhar Ratnakumar</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="static/favicon.jpeg" rel="icon" /><meta content="Sridhar Ratnakumar" name="author" /><meta content="The goal of this article is to get you comfortable managing simple Haskell programs and projects using the Nix package manager without going too much into the details." name="description" /><link href="https://www.srid.ca/haskell-nix" rel="canonical" /><meta content="Nix recipes for Haskellers" property="og:title" /><meta content="Sridhar Ratnakumar" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[{"@context":"https://schema.org","itemListElement":[{"name":"Sridhar Ratnakumar","item":"https://www.srid.ca","@type":"ListItem","position":1},{"name":"Blog","item":"https://www.srid.ca/blog","@type":"ListItem","position":2}],"@type":"BreadcrumbList"},{"@context":"https://schema.org","itemListElement":[{"name":"Haskell","item":"https://www.srid.ca/haskell","@type":"ListItem","position":1}],"@type":"BreadcrumbList"}]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(224,57,151,0.1)}body nav.bottomPane{background-color:rgba(224,57,151,2.0e-2)}body div#footnotes{border-top-color:#e03997}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#e03997;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(224,57,151,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><link href="static/background-pattern.css" rel="stylesheet" />
<style>
    #zettel-container {
        max-width: 800px !important;
    }

    h2 {
        text-align: left;
        font-style: oblique;
        border-bottom: none !important;
    }

    /* Hide the query divider */
    div.pandoc section.tag-query-results .divider {
        display: none !important;
    }
    div.pandoc section.tag-query-results .ui.list {
        border-left: solid gray 1px !important;
        padding-left: 1em;
    }

    .leftlisting {
        width: 50%;
    }

    .rightlisting {
        width: 50%;
        float: right;
    }
</style>

<!-- Syntax highlighting of code blocks -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-okaidia.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script><!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><nav class="flipped tree deemphasized" id="zettel-uptree" style="transform-origin: 50%"><ul class="root"><li><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="blog">Blog</a></span></span></div><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href=".">Sridhar Ratnakumar</a></span></span></div></li></ul></li><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="haskell">Haskell</a></span></span></div></li></ul></li></ul></nav><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Nix recipes for Haskellers</h1><p>The goal of this article is to get you comfortable managing simple <a href="https://www.haskell.org/">Haskell</a> programs and projects using the <strong>Nix</strong> package manager without going too much into the details.</p><h2 id="prerequisites">Prerequisites</h2><p>You are running either Linux or macOS, and have installed the <strong>Nix</strong> package manager using <a href="https://nixos.org/nix/">these instructions</a> <span data-nosnippet=""><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup></span>. You do <em>not</em> need to install anything else, including needing to install Haskell, as Nix will manage that for you.</p><h2 id="simple-programs">Simple programs</h2><p>Let us begin with the simplest Haskell program, try to compile and run it with the help of Nix.</p><pre><code class="haskell language-haskell">-- HelloWorld.hs
module Main where

main :: IO ()
main = putStrLn &quot;Hello World&quot;</code></pre><p>Haskell code is compiled by GHC, which is provided by the Nix package called “ghc”. How do we install it? According to the <a href="https://nixos.org/nix/manual/#chap-package-management">Nix manual</a> this can be done by running the command <code>nix-env -i ghc</code>. For Haskell developers, there is a better approach. Instead of installing packages in a global environment, you may install them to an <em>isolated</em> area and launch a shell with those packages in its environment. This is done using the <code>nix-shell -p ghc</code> command.</p><pre><code class="bash language-bash"># This drops us in a bash shell with ghc package installed and 
# $PATH updated.
$ nix-shell -p ghc
...
# Now let&#39;s run our module.
[nix-shell:~] runhaskell HelloWorld.hs
Hello World</code></pre><p>As you can see, nix-shell dropped us in a shell environment with the “ghc” package installed and activated. This puts <code>runhaskell</code> (part of the “ghc” package) in your PATH, running which will compile and run your first Haskell program. When you exit the nix-shell ([Ctrl+D][kbd]), <code>runhaskell</code> will no longer be in scope, however the “ghc” package will have been cached so that subsequent invocations of <code>nix-shell -p ghc</code> would not have to download and install it once again.<span data-nosnippet=""><sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup></span></p><h3 id="using-library-dependencies">Using library dependencies</h3><p>What if our program relied on an third-party Haskell library? The following program uses the <a href="http://hackage.haskell.org/package/brick">brick</a> UI library.</p><pre><code class="haskell language-haskell">-- HelloWorld.hs
module Main where

import Brick

ui :: Widget ()
ui = str &quot;Hello, world!&quot;

main :: IO ()
main = simpleMain ui</code></pre><p>We can no longer use the “ghc” package here. Fortunately, Nix is also a programming language, and as such as we can evaluate arbitrary Nix expressions to create a customized environment. Official Nix packages come from the <a href="https://github.com/NixOS/nixpkgs">nixpkgs</a> channel, which provides a function called <code>ghcWithPackages</code>. Evaluating this function, passing it a list of Haskell libraries (already in nixpkgs), will create an environment with both GHC and the specific Haskell libraries installed.</p><pre><code class="bash language-bash">$ nix-shell \
    -p &quot;haskellPackages.ghcWithPackages (p: [p.brick])&quot; \
    --run &quot;runhaskell HelloWorld.hs&quot;</code></pre><p>The <code>--run</code> argument will invoke the given command instead of dropping us in an interactive shell. This single command does <em>so much</em>—install the Haskell compiler with the requested libraries, compile our program and run it!</p><h3 id="haskell-scripts">Haskell scripts</h3><p>You can use the above nix-shell command in the shebang to create self-contained Haskell scripts. Let us see an example, but using <a href="https://github.com/ndmitchell/ghcid">ghcid</a>, instead of runhaskell:</p><pre><code class="haskell language-haskell">-- myscript.hs
#! /usr/bin/env -S&quot;ANSWER=42&quot; nix-shell
#! nix-shell -p ghcid
#! nix-shell -p &quot;haskellPackages.ghcWithPackages (p: [p.shower])&quot;
#! nix-shell -i &quot;ghcid -c &#39;ghci -Wall&#39; -T main&quot;

import Shower (printer)
import System.Environment (getEnv)

main :: IO ()
main = do
  let question = &quot;The answer to life the universe and everything&quot;
  answer &lt;- getEnv &quot;ANSWER&quot;
  printer (question, &quot;is&quot;, answer)</code></pre><p>Run <code>chmod u+x myscript.hs</code> to make it an executable, and then run it as <code>./myscript.hs</code>. Not only is it a self-sufficient script (depending on nothing but nix in the environment), but thanks to ghcid it also re-compiles and re-launches itself whenever it changes! See more examples <a href="https://github.com/srid/aoc2019">here</a>.</p><h2 id="cabal-project">Cabal project</h2><p>Haskell projects normally use <a href="https://www.haskell.org/cabal/">cabal</a>, and you might already be familiar with <a href="https://haskellstack.org/">Stack</a> which uses Cabal underneath. Nix is an alternative to Stack with many advantanges, chief of them being the creation of reproducible development environments using declarative configuration that handles even non-Haskell packages.</p><p>Adding Nix support to most Cabal projects is a matter of creating a file called <code>default.nix</code> in the project root (just make sure you have a .cabal file named appropriately). This file is by default used by commands like <code>nix-build</code> and <code>nix-shell</code>, which we will use when developing the project.</p><pre><code class="nix language-nix"># default.nix
let 
  pkgs = import &lt;nixpkgs&gt; { };
in 
  pkgs.haskellPackages.developPackage {
    root = ./.;
    modifier = drv:
      pkgs.haskell.lib.addBuildTools drv (with pkgs.haskellPackages;
        [ cabal-install
          ghcid
        ]);
  }</code></pre><p>Now if you run <code>nix-shell</code> it will drop you in a shell with all Haskell dependencies (from .cabal file) installed. This will be your development shell; from here you can run your usual <code>cabal</code> commands, and everything will function as expected.</p><pre><code class="bash language-bash">$ nix-shell
...
[nix-shell:~] cabal new-build
..</code></pre><p>If you only want to <em>build</em> the project, creating a final executable, use <code>nix-build</code>.</p><h3 id="development-dependencies">Development dependencies</h3><p>Notice the <code>modifier</code> attribute in the previous example. It specifies a list of build dependencies, using the <code>addBuildTools</code> function, that becomes available when we run either <code>nix-shell</code> or <code>nix-build</code>. Here, you will specify all the packages you need for development.<span data-nosnippet=""><sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup></span> We speficied two—<code>cabal</code> and <code>ghcid</code>. If you removed <code>cabal</code> from this list, then cabal will not be in scope of your nix-shell. We added <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a>, which can be used to run a daemon that will recompile your project if any of the source files change; go ahead and give it a try using <code>nix-shell --run ghcid</code>.</p><h3 id="overriding-dependencies">Overriding dependencies</h3><p>The above will work as long as the libraries your project depends on exist on nixpkgs (which itself is derived from Stackage). That will not always be the case and you may want to <em>override</em> certain dependencies.</p><p>In Nix overriding library packages is rather straightforward. The aforementioned <code>developPackage</code> function exposes this capability via the <code>source-overrides</code> attribute. Suppose your cabal project depends on the <a href="https://github.com/monadfix/named">named</a> package at a particular git revision (<code>e684a00</code>), then you would modify your <code>default.nix</code> to look like:</p><pre><code class="nix language-nix">let
  pkgs = import &lt;nixpkgs&gt; { };
  compilerVersion = &quot;ghc865&quot;; 
  compiler = pkgs.haskell.packages.&quot;${compilerVersion}&quot;;
in
  compiler.developPackage {
    root = ./.;
    source-overrides = {
      named = builtins.fetchTarball 
        &quot;https://github.com/monadfix/named/archive/e684a00.tar.gz&quot;;
    };
    modifier = drv:
      pkgs.haskell.lib.addBuildTools drv (with pkgs.haskellPackages;
        [ cabal-install
          ghcid
        ]);
  }</code></pre><p>Now, if you re-run <code>nix-shell</code> or <code>nix-build</code> Nix will rebuild your package, and any packages depending on <code>named</code>, using the new source.</p><p>Note that this example also demonstrates how to select a compiler version.</p><h3 id="multi-package-cabal-project">Multi-package cabal project</h3><p><code>developPackage</code> cannot be used if you use the cabal project feature, containing multiple packages. You will have to go a few steps lower in the abstraction ladder, and use the underlying Nix functions (<code>callCabal2nix</code>, <code>shellFor</code>, <code>extend</code>, <code>inNixShell</code>) in the <code>default.nix</code> of a multiple-package cabal project. See <a href="https://github.com/kowainik/summoner/blob/60de4f2f087e5bd2beaad9253e7eded731cfbaaf/default.nix">summoner’s default.nix</a> for a full example.</p><h2 id="caching">Caching</h2><p>Nix has builtin support for caching. Packages from the nixpkgs channel are already cached in the official cache. If you want to provide caching for your own packages, you may use <a href="https://nixos.wiki/wiki/Binary_Cache">nix-serve</a> (from NixOS) or <a href="https://cachix.org/">Cachix</a> (third-party service).</p><h2 id="continuous-integration">Continuous Integration</h2><p>Setting up CI for a Haskell project that already uses Nix is rather simple. If you use Github and Cachix, the easiest way is to use <a href="https://github.com/cachix/cachix-action">the cachix Github Action</a>. <span data-nosnippet=""><sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup></span></p><h2 id="external-links">External links</h2><ul><li><a href="https://haskell4nix.readthedocs.io/">Official Nix manual on using Haskell</a></li><li><a href="https://nixos.org/nixos/nix-pills/">Nix Pills</a>: a tutorial series on using Nix</li><li><a href="https://github.com/input-output-hk/haskell.nix">haskell.nix</a>: some people recommend haskell.nix</li></ul><p><span class="zettel-link-container folgeinv"><span class="zettel-link"><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span><a href="blog">Blog</a></span></span> post created on <span class="zettel-link-container errors"><span class="zettel-link" title="Wiki-link does not refer to any existing zettel"><a>2019-12-03</a></span></span>, under <span class="zettel-link-container folgeinv"><span class="zettel-link"><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span><a href="haskell">Haskell</a></span></span></p><div id="footnotes"><ol><li id="fn1"><p>Alternatively, if you are feeling adventurous enough, you may install <a href="https://nixos.org/">NixOS</a>, a Linux distribution based on Nix.</p><a href="#fnref1">↩︎</a></li><li id="fn2"><p>Nix is a <em>general</em> package manager. You may use it to manage not only haskell packages, but also any other program. For example, to temporarily use the <code>tree</code> package, so as to dispay the directory tree of the current directory, you would run: <code>nix-shell -p tree --run tree</code>.</p><a href="#fnref2">↩︎</a></li><li id="fn3"><p>Use <code>pkgs.lib.haskell.inNixShell</code> to conditionally include dependencies on nix-shell but not nix-build.</p><a href="#fnref3">↩︎</a></li><li id="fn4"><p>If you are however using a <em>self-hosted</em> runner in Github Actions with public repos, read this <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/about-self-hosted-runners#self-hosted-runner-security-with-public-repositories">security warning</a>.</p><a href="#fnref4">↩︎</a></li></ol></div></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2019-12-03">2019-12-03</time></div></div></article><nav class="ui attached segment deemphasized backlinksPane" id="neuron-backlinks-pane"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" title="2020-09-29"><a href="nix-haskell-static-binaries">Building Static Haskell binaries using Nix</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Nixify your project: write a <code>default.nix</code> (See <span class="zettel-link-container cf"><span class="zettel-link" title="Zettel: Nix recipes for Haskellers"><a href="haskell-nix">Nix recipes for Haskellers</a></span></span>)</div></li></ul></li><li><span class="zettel-link-container cf"><span class="zettel-link"><a href=".">Sridhar Ratnakumar</a></span></span><ul class="context-list" style="zoom: 85%;"></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">blog</span></div></nav><nav class="ui bottom attached icon compact inverted menu pink" id="neuron-nav-bar"><!--replace-start-9--><a class="item" href="." title="Home"><i class="home icon"></i></a><!--replace-end-9--><a class="item" href="https://github.com/srid/www.srid.ca/edit/master/./Nix recipes for Haskellers.md" title="Edit this page"><i class="edit icon"></i></a><a class="right item" href="impulse" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.25.1" /></a></div></div></div></body></html>