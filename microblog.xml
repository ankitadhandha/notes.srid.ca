<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Srid‚Äôs microblog üêú - Sridhar Ratnakumar</title><id>https://notes.srid.ca/microblog</id><updated>2021-04-02</updated><link href="https://notes.srid.ca/microblog"/><icon>https://notes.srid.castatic/favicon.jpeg</icon><entry><id>https://notes.srid.ca/fsharp-exploration</id><title type="text">A brief F# exploration</title><updated>2021-04-02</updated><content type="html">&lt;p&gt;I have been writing full-stack web apps in &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;haskell&#34;&gt;Haskell&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; using functional reactive programming (&lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;reflex-frp&#34;&gt;Reflex-FRP&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;) for 3 years now. Curiosity stuck me as to find out what the FP languages other than Haskell had to offer in this area.&lt;/p&gt;&lt;p&gt;My critieria were:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Must be a functional programming language&lt;/li&gt;&lt;li&gt;Should compile to JS or Wasm&lt;/li&gt;&lt;li&gt;Must run natively on backend without nodeJS (rules out the likes of &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;purescript&#34;&gt;PureScript&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Haskell‚Äôs GHCJS (esp. when used with &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;obelisk&#34;&gt;Obelisk&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;) satisfies all of this, but there is one pain-point: the future of GHCJS and Reflex seems to be in the hands of &lt;em&gt;one&lt;/em&gt; company, Obsidian Systems.&lt;/p&gt;&lt;p&gt;That lead me to F#, a hybrid FP language (‚Äúhybrid‚Äù because it supports OOP, which is essential to integrate with the rest of the .NET ecosystem). I‚Äôve documented my learnings here: &lt;a href=&#34;https://srid.github.io/learning-fsharp/&#34;&gt;https://srid.github.io/learning-fsharp/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;What I found impressive:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://devblogs.microsoft.com/dotnet/announcing-net-5-0/#unified-platform-vision&#34;&gt;.NET 5.0&lt;/a&gt; ecosystem is a pleasure to work with (and it works well on Linux with VSCode); and you can create cross-platform apps &lt;a href=&#34;https://github.com/srid/neuron/pull/586&#34;&gt;more straightforwardly&lt;/a&gt; than in Haskell.&lt;ul&gt;&lt;li&gt;If I were to start developing &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;neuron&#34;&gt;Neuron&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; today, I probably would use F#.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Microsoft has a great full-stack web development story; and they support WebAssembly (&lt;a href=&#34;https://srid.github.io/learning-fsharp/Blazor&#34;&gt;&lt;code&gt;Blazor&lt;/code&gt;&lt;/a&gt;), including a framework for real-time communication (&lt;code&gt;SignalR&lt;/code&gt;).&lt;ul&gt;&lt;li&gt;In F#, &lt;a href=&#34;https://fsbolero.io/&#34;&gt;Bolero&lt;/a&gt; today is the go-to framework to make use of the above technology.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;I find it reassuring that I can rely on Microsoft to advance the full-stack web development more than one small consultancy (Obsidian Systems) with less than transparent open source development in the Haskell land.&lt;ul&gt;&lt;li&gt;That said, I have some hopes that Tweag‚Äôs &lt;a href=&#34;https://github.com/tweag/asterius&#34;&gt;Asterius&lt;/a&gt; catches up and facilitates a whole new ecosystem of full-stack development tools in Haskell.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;There are some things that are better in the Haskell ecosystem, though. For example, fast development reload workflow works super well in Haskell, thanks to &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;ghcid&#34;&gt;ghcid&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;. In .NET, you have &lt;code&gt;dotnet watch&lt;/code&gt; - but that recompiles the whole project on every change leading to annoying delay; it made me &lt;a href=&#34;https://github.com/srid/Feather/issues/10&#34;&gt;switch back&lt;/a&gt; to using Haskell for DSL-based static sites, while live-reload is essential to get quick feedback on things like CSS changes. Also, having to work with OOP-based .NET libraries (written in C&lt;span&gt;&lt;code class=&#34;inline-tag&#34;&gt;#)&lt;/code&gt;&lt;/span&gt; can be annoyance from a pure-FP perspective, though that can be dealt with by wrapping these libraries in a functional layer, and then using that in the F# program.&lt;/p&gt;&lt;p&gt;F# will continue to remain in my toolbox. If the aforementioned downsides are irrelevant, I might just use it in my next project over Haskell, which is still my go-to language today.&lt;/p&gt;</content><link href="https://notes.srid.ca/fsharp-exploration"/></entry><entry><id>https://notes.srid.ca/windows-iso-linux-usb</id><title type="text">Burning Windows ISO to USB disk in Linux</title><updated>2021-03-14</updated><content type="html">&lt;p&gt;The Windows 10 ISO contains a file named &lt;code&gt;sources/install.wim&lt;/code&gt; that weights more than 4G, which is the maximum file size on &lt;a href=&#34;https://en.wikipedia.org/wiki/File_Allocation_Table&#34;&gt;FAT filesystems&lt;/a&gt;. So the USB disk must be partitioned using NTFS, however BIOS doesn‚Äôt supporting booting from NTFS USB partitions (for whatever reason); this can be worked around by creating the bootable drive using &lt;a href=&#34;https://github.com/slacka/WoeUSB&#34;&gt;WoeUSB&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;On NixOS,&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;bash language-bash&#34;&gt;nix-shell -p woeusb --run woeusbgui&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Be sure to enable NTFS support in the kernel first; see &lt;a href=&#34;https://nixos.wiki/wiki/NTFS&#34;&gt;https://nixos.wiki/wiki/NTFS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;In WoeUSB‚Äôs dialog, select ‚ÄúNTFS‚Äù as the file system. The resultant USB should properly boot into Windows installer.&lt;/p&gt;</content><link href="https://notes.srid.ca/windows-iso-linux-usb"/></entry><entry><id>https://notes.srid.ca/protonvpn-nixos-container</id><title type="text">A NixOS container for ProtonVPN</title><updated>2021-03-03</updated><content type="html">&lt;p&gt;&lt;span class=&#34;zettel-link-container folgeinv&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;span data-nosnippet=&#34;&#34; style=&#34;user-select: none; color: gray&#34; title=&#34;Folgezettel&#34;&gt;#&lt;/span&gt;&lt;a href=&#34;nixos&#34;&gt;NixOS&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;‚Äôs &lt;a href=&#34;https://nixos.org/manual/nixos/stable/#ch-containers&#34;&gt;declarative container management&lt;/a&gt; provides a way to &lt;em&gt;declaratively&lt;/em&gt; configure an &lt;em&gt;entire&lt;/em&gt; (NixOS) Linux system to be run inside the host. Below you will find the Nix config that configures a new container named ‚Äúvpn‚Äù in the following way:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Add the specified system packages&lt;/li&gt;&lt;li&gt;Add the specified user&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Of course, you can do more - such as adding systemd services, configuring firewall, etc. But for this post, we are interested only in creating an &lt;strong&gt;isolated system&lt;/strong&gt; that will connect to a VPN network whilst leaving the rest of your computer remain connected without VPN&lt;span data-nosnippet=&#34;&#34;&gt;&lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn1&#34; id=&#34;fnref1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/span&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;nix language-nix&#34;&gt;  containers.vpn = { 
    config =  { config, pkgs, ... }: {
      environment.systemPackages = with pkgs; [
        protonvpn-cli  # Our VPN client
        tmux
        youtube-dl
        aria
      ];
      users.extraUsers.user = {
        isNormalUser = true;
        uid = 1000;
      };
    };
  };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Add the above to your host‚Äôs &lt;code&gt;configuration.nix&lt;/code&gt;, and then &lt;code&gt;nixos-rebuild switch&lt;/code&gt;. Now you can start the container as:&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;sh language-sh&#34;&gt;sudo nixos-container start vpn&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And access its root shell as:&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;sh language-sh&#34;&gt;sudo nixos-container root-login vpn&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From within the root shell, you will want to login to your &lt;a href=&#34;https://protonvpn.com/&#34;&gt;ProtonVPN&lt;/a&gt; account:&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;sh language-sh&#34;&gt;protonvpn init&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Connect to VPN,&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;sh language-sh&#34;&gt;protonvpn c --fastest&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then login as a non-root user (important!) with tmux:&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;sh language-sh&#34;&gt;su - user -c &amp;quot;tmux new -A&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From here, you can use your favourite network clients to access the outside world through VPN.&lt;/p&gt;&lt;div id=&#34;footnotes&#34;&gt;&lt;ol&gt;&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;In particular, the &lt;code&gt;protonvpn&lt;/code&gt; Linux client is not always reliable over long-time; it is not uncommon to find my home-server host unreachable from the outside due to a frozen VPN connection.&lt;/p&gt;&lt;a href=&#34;#fnref1&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><link href="https://notes.srid.ca/protonvpn-nixos-container"/></entry><entry><id>https://notes.srid.ca/neuron-feed</id><title type="text">Use Neuron, get RSS for free</title><updated>2021-02-28T20:45</updated><content type="html">&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Web_feed&#34;&gt;Atom, not RSS&lt;/a&gt; - but you get the idea.&lt;/p&gt;&lt;p&gt;Instead of writing your own static site generator, and write code to laboriously generate RSS feeds (which are all useful exercise in learning) - why not use &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;neuron&#34;&gt;Neuron&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-nosnippet=&#34;&#34;&gt;&lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn1&#34; id=&#34;fnref1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/span&gt;, and add the following to your, say, &lt;code&gt;blog.md&lt;/code&gt; and call it a day?&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;yaml language-yaml&#34;&gt;---
feed:
  count: 5
---&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is all it takes to generate an atom feed, &lt;code&gt;blog.xml&lt;/code&gt;, that will aggregate all of your blog posts linked from &lt;code&gt;blog.md&lt;/code&gt;. See neuron‚Äôs documentation on the &lt;a href=&#34;https://neuron.zettel.page/feed&#34;&gt;Web feeds plugin&lt;/a&gt; for details.&lt;/p&gt;&lt;p&gt;On this site, you have three examples: add any of these ‚Äì &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;blog&#34;&gt;Blog&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34; title=&#34;Zettel: Srid‚Äôs microblog üêú&#34;&gt;&lt;a href=&#34;microblog&#34;&gt;Srid&amp;#39;s microblog&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;, or &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;neuron&#34;&gt;Neuron&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; ‚Äì to your feed reader, if you want to keep yourself abreast of new content in those zettels.&lt;/p&gt;&lt;div id=&#34;footnotes&#34;&gt;&lt;ol&gt;&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;See &lt;a href=&#34;https://github.com/srid/neuron-template&#34;&gt;https://github.com/srid/neuron-template&lt;/a&gt; for a template to instantly get started with little fuss (requires a GitHub account).&lt;/p&gt;&lt;a href=&#34;#fnref1&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><link href="https://notes.srid.ca/neuron-feed"/></entry><entry><id>https://notes.srid.ca/Pretty_URLs_in_Neuron</id><title type="text">Pretty URLs in Neuron</title><updated>2021-02-23T16:35</updated><content type="html">&lt;p&gt;Just pushed a change that enables pretty URLs in neuron generated sites. This already works in GitHub Pages (&lt;code&gt;/foo&lt;/code&gt; returns &lt;code&gt;/foo.html&lt;/code&gt;). &lt;span&gt;&lt;code class=&#34;inline-tag&#34;&gt;#Neuron&lt;/code&gt;&lt;/span&gt; had to be changed to make generated HTML link to &lt;code&gt;/foo&lt;/code&gt; instead of &lt;code&gt;/foo.html&lt;/code&gt;. This behaviour is controlled by:&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;sh language-sh&#34;&gt;neuron gen --pretty-urls&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which is also what &lt;a href=&#34;https://github.com/srid/neuron-template&#34;&gt;neuron-template&lt;/a&gt; does by default.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Demo&lt;/strong&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;em&gt;This&lt;/em&gt; website&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://neuron.zettel.page/&#34;&gt;https://neuron.zettel.page/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://alien-psychology.zettel.page/&#34;&gt;https://alien-psychology.zettel.page/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://zk.zettel.page/&#34;&gt;https://zk.zettel.page/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;other-changes&#34;&gt;Other changes&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Default slug&lt;/strong&gt; is now minimally transformed: especially with &lt;code&gt;--pretty-urls&lt;/code&gt;, it is useful to allow the user to reuse zettel title ID for url (except for replacing whitespace for legibility).&lt;ul&gt;&lt;li&gt;One can always explicitly specify a &lt;code&gt;slug&lt;/code&gt; in the zettel YAML, as &lt;a href=&#34;https://neuron.zettel.page/&#34;&gt;https://neuron.zettel.page/&lt;/a&gt; does for virtully all of its zettels.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Ignore zettels without date in ‚Äútimeline‚Äù queries.&lt;/li&gt;&lt;/ul&gt;</content><link href="https://notes.srid.ca/Pretty_URLs_in_Neuron"/></entry></feed>