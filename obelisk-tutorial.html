<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Obelisk tutorial, Markdown preview with Reflex - Sridhar Ratnakumar</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="static/favicon.jpeg" rel="icon" /><meta content="Sridhar Ratnakumar" name="author" /><meta content="In this article, I’ll describe how to get a full-stack Haskell application up and running. In particular, the app will render user-entered Markdown text in real-time (the final version is hosted at https://commonmark.srid.ca). Notably, our app will use Haskell even on the frontend. This is made poss" name="description" /><link href="https://www.srid.ca/obelisk-tutorial" rel="canonical" /><meta content="Obelisk tutorial, Markdown preview with Reflex" property="og:title" /><meta content="Sridhar Ratnakumar" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[{"@context":"https://schema.org","itemListElement":[{"name":"Sridhar Ratnakumar","item":"https://www.srid.ca","@type":"ListItem","position":1},{"name":"Blog","item":"https://www.srid.ca/blog","@type":"ListItem","position":2}],"@type":"BreadcrumbList"},{"@context":"https://schema.org","itemListElement":[{"name":"Haskell","item":"https://www.srid.ca/haskell","@type":"ListItem","position":1},{"name":"Reflex-FRP","item":"https://www.srid.ca/reflex-frp","@type":"ListItem","position":2},{"name":"Obelisk","item":"https://www.srid.ca/obelisk","@type":"ListItem","position":3}],"@type":"BreadcrumbList"}]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(224,57,151,0.1)}body nav.bottomPane{background-color:rgba(224,57,151,2.0e-2)}body div#footnotes{border-top-color:#e03997}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#e03997;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(224,57,151,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><link href="static/background-pattern.css" rel="stylesheet" />
<style>
    #zettel-container {
        max-width: 800px !important;
    }

    h2 {
        text-align: left;
        font-style: oblique;
        border-bottom: none !important;
    }

    /* Hide the query divider */
    div.pandoc section.tag-query-results .divider {
        display: none !important;
    }
    div.pandoc section.tag-query-results .ui.list {
        border-left: solid gray 1px !important;
        padding-left: 1em;
    }

    .leftlisting {
        width: 50%;
    }

    .rightlisting {
        width: 50%;
        float: right;
    }
</style>

<!-- Syntax highlighting of code blocks -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-okaidia.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script><!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><nav class="flipped tree deemphasized" id="zettel-uptree" style="transform-origin: 50%"><ul class="root"><li><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="blog">Blog</a></span></span></div><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href=".">Sridhar Ratnakumar</a></span></span></div></li></ul></li><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="obelisk">Obelisk</a></span></span></div><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="reflex-frp">Reflex-FRP</a></span></span></div><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="haskell">Haskell</a></span></span></div></li></ul></li></ul></li></ul></li></ul></nav><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Obelisk tutorial, Markdown preview with Reflex</h1><p>In this article, I’ll describe how to get a full-stack Haskell application up and running. In particular, the app will render user-entered Markdown text in real-time (the final version is hosted at <a href="https://commonmark.srid.ca">https://commonmark.srid.ca</a>). Notably, our app will use Haskell even on the frontend. This is made possible by the <a href="https://github.com/ghcjs/ghcjs">GHCJS</a> compiler, that compiles Haskell code to JavaScript.</p><p>We will not work directly with GHCJS, however, and instead will use the <span class="zettel-link-container cf"><span class="zettel-link"><a href="reflex-frp">Reflex-FRP</a></span></span> library, through the excellent <span class="zettel-link-container folgeinv"><span class="zettel-link"><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span><a href="obelisk">Obelisk</a></span></span> full-stack framework.</p><h2 id="create-an-obelisk-project">Create an Obelisk project</h2><p>First and foremost, make sure you have <a href="https://github.com/obsidiansystems/obelisk#installing-obelisk">Obelisk installed</a>, and then follow along.</p><p>Obelisk includes a command called <code>ob</code> that can be used to initialize a project. We will also use git to keep track of changes:</p><pre><code class="bash language-bash">mkdir MarkdownPreview
cd ./MarkdownPreview
# Create an Obelisk project
ob init
# Add to git
git init
git add .
git commit -m &quot;first commit&quot;</code></pre><p>This gives us a project layout with three Haskell packages: <code>backend</code>, <code>common</code> and <code>frontend</code>. As the names indicate, <code>frontend</code> contains the Haskell code that ultimate gets compiled to JavaScript. The <code>common</code> package however contains code that is shared between the backend and the frontend. This is extremely useful for type sharing, which is impossible with something like Elm or PureScript (without explicit conversion).</p><pre><code class="sh language-sh">backend
cabal.project
common
config
default.nix
frontend
shell.nix
static</code></pre><p>You will notice that Obelisk uses <span class="zettel-link-container cf"><span class="zettel-link"><a href="nix">Nix</a></span></span> to build your project. The command <code>ob run</code> (described below) will abstract over the Nix stuff, including any GHCi handling, so you do not have to deal directly with Nix except for overriding dependencies.</p><h2 id="running-hello-world">Running hello world</h2><p>Now, it is time to run our app.</p><pre><code class="sh language-sh">ob run</code></pre><p>This command may take a while to finish the very first time it is run, as it would need to download packages from the Nix caches. At the end you would expect to see: <code>Frontend running on http://localhost:8000/</code>. Your obelisk app will be accessible at that URL.</p><h3 id="interlude-ob-run-reloads-your-code">Interlude: <code>ob run</code> reloads your code</h3><p>So what does this <code>ob run</code> command do? Think of it as <code>stack run</code> or <code>cabal run</code> - but it also recompiles changed sources and reloads application. <code>ob run</code> uses <a href="https://github.com/ndmitchell/ghcid">ghcid</a> underneath, in combination with custom <code>ghci</code> config to specify the modules to reload.</p><p>There is also <code>ob repl</code> which gives you a GHCi repl for your project. As well as <code>ob hoogle</code> providing a local Hoogle server for project and its dependencies.</p><h2 id="add-commonmark-hs-dependency">Add commonmark-hs dependency</h2><p>Our application will use the Pure Haskell Markdown parser <a href="https://github.com/jgm/commonmark-hs">commonmark-hs</a>, which is written by the author of Pandoc, who intends to <a href="https://github.com/jgm/commonmark-hs/issues/1#issuecomment-395802118">migrate Pandoc over to it</a> eventually.</p><p>We will also use the latest version from Git, instead of Hackage. Some <a href="https://nixos.org/nix/">Nix-fu</a> is helpful at this stage. But the main thing you need to know, in order to add a custom Haskell dependency, is the following general workflow:</p><ul><li>Clone the git repo under a subdirectory</li><li>“Pack” it using <code>ob thunk</code></li><li>Load it in <code>default.nix</code> using <code>hackGet</code></li></ul><p>As briefly as possible, you would do this for commonmark-hs as follows:</p><pre><code class="sh language-sh"># Get the source
git clone https://github.com/jgm/commonmark-hs.git dep/commonmark-hs
...
# Pack it
ob thunk pack dep/commonmark-hs
...</code></pre><p>Next, edit your <code>default.nix</code> and:</p><ul><li>Add <code>hackGet</code> and <code>pkgs</code> as arguments to the <code>project</code> if they don’t already exist</li><li>Use the packed thunk by calling <code>hackGet</code></li><li>The git rep contains multiple Haskell packages; use <code>commonmark</code> and <code>commonmark-extensions</code></li></ul><p>Here’s how your <code>default.nix</code> should look:</p><pre><code class="nix language-nix">project ./. ({ pkgs, hackGet, ... }: {
  packages = let 
    commonmarkSrc = hackGet ./dep/commonmark-hs;
  in {
    commonmark = commonmarkSrc + &quot;/commonmark&quot;;
    commonmark-extensions = commonmarkSrc + &quot;/commonmark-extensions&quot;;
  };
  ...
})</code></pre><p>If you run <code>ob run</code> at this point, it may complain about further missing dependencies. Let’s override each of them:</p><pre><code class="sh language-sh">git clone https://github.com/jgm/emojis.git dep/emojis
ob thunk pack dep/emojis</code></pre><p>Go back to <code>default.nix</code>, and add this new dependency to the <code>packages</code> attribute:</p><pre><code class="nix language-nix">    ...
    emojis = hackGet ./dep/emojis;</code></pre><p>As we will be using commonmark directly in the frontend, go ahead and add these to <code>frontend.cabal</code> (under the library stanza):</p><pre><code class="haskell language-haskell">-- frontend/frontend.cabal
               ...
               , commonmark
               , commonmark-extensions
  </code></pre><p>Restart <code>ob run</code>, which should build the the new dependency before starting our app.</p><h3 id="interlude-what-is-an-obelisk-thunk">Interlude: What is an Obelisk thunk?</h3><p>If you are familiar with <a href="https://www.srid.ca/1948201.html#overriding-dependencies">Haskell overrides in Nix</a>, then think of the obelisk thunk mechanism as an abstraction on top. A “packed” thunk is essentially similar to Nix’s <code>fetchGit</code> in that you specify the exact source revision of the dependency to use.</p><p>But a thunk can also be “unpacked”, using <code>ob thunk unpack</code>, which – in addition to unpacking it as a git clone – has the effect of adding it to <code>ob run</code> and <code>ob repl</code> sessions. For example, you could unpack the above commonmark thunk using <code>ob thunk unpack dep/commonmark-hs</code> and restart <code>ob run</code>. Now, when you hack on <code>./dep/commonmark-hs</code> and change its Haskell sources, <code>ob run</code> will automatically reload the app using the modified commonmark-hs. See the Obelisk <a href="https://github.com/obsidiansystems/obelisk/blob/master/ChangeLog.md#v0500---2020-02-07">ChangeLog</a> for details.</p><h2 id="lets-add-a-textbox">Let’s add a textbox</h2><p>If you are unfamiliar with Reflex, checkout <a href="https://reflex-frp.org/get-started">the official guide</a>. All our frontend code is defined in the <code>frontend/src/Frontend.hs</code> file. With <code>ob run</code> running by side, open that module and try changing a few things, like the title - and the app should update. Let’s add a textbox element where the user would write their Markdown text.</p><p>Somewhere in <code>_frontend_body</code>, add the following:</p><pre><code class="haskell language-haskell">markdownText :: Dynamic t T.Text &lt;-
  fmap value $ textAreaElement $
    def
    &amp; initialAttributes .~ (&quot;style&quot; =: &quot;width:50%;height:15em;&quot;)</code></pre><p><code>markdownText</code> is a reflex Dynamic that holds the user-entered text.</p><h2 id="parse-markdown">Parse Markdown</h2><p>Now it is time to actually use the commonmark library. Let’s import it:</p><pre><code class="haskell language-haskell">import qualified Commonmark as CM

renderMarkdown :: T.Text -&gt; Either CM.ParseError (CM.Html ())
renderMarkdown =
  CM.commonmark &quot;markdown&quot;</code></pre><p>The <code>renderMarkdown</code> function will parse our Markdown and return the HTML representation of it. Calling <code>show</code> on the Right value gets us the raw HTML.</p><h2 id="render-to-html">Render to HTML</h2><p>Finally let’s plug everything together. We want to parse and render the resulting HTML every time the user changes the textbox. Reflex’s Dynamic automatically updates, so let’s use that.</p><pre><code class="haskell language-haskell">result &lt;- eitherDyn $ fmap renderMarkdown markdownText
dyn_ $ ffor result $ \case
  Left err -&gt;
    dyn_ $ ffor err $ \_ -&gt; text &quot;Parse error&quot;
  Right htmlVal -&gt;
    prerender_ blank $ void $ elDynHtml&#39; &quot;div&quot; $ T.pack . show &lt;$&gt; htmlVal
</code></pre><p>That’s all it takes! Now as you type the Markdown text, its live preview will automatically update next to the textbox.</p><p>You can even hack on commonmark-hs (see the Obelisk thunk interlude above), and have <code>ob run</code> automatically reload when the library sources change. This is extremely handy if you want to play with the internals of the Markdown parser and see its live result in the browser.</p><h2 id="further-resources">Further resources</h2><ul><li><p>Source code for this app on Github: <a href="https://github.com/srid/MarkdownPreview">https://github.com/srid/MarkdownPreview</a></p></li><li><p>Fully built version of it running at: <a href="https://commonmark.srid.ca/">https://commonmark.srid.ca/</a></p></li></ul><p><span class="zettel-link-container folgeinv"><span class="zettel-link"><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span><a href="blog">Blog</a></span></span> post created under <span class="zettel-link-container folgeinv"><span class="zettel-link"><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span><a href="obelisk">Obelisk</a></span></span></p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2020-05-08">2020-05-08</time></div></div></article><nav class="ui attached segment deemphasized backlinksPane" id="neuron-backlinks-pane"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" title="2020-07-28"><a href="neuron-0.6">Neuron 0.6 released</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc"><p>Previous versions of neuron used the <a href="https://hackage.haskell.org/package/mmark">mmark</a> parser which advertises itself as being “strict”. This prevented certain links from working as they caused the parser to fail. In version 0.6, I switched over to use <a href="https://github.com/jgm/commonmark-hs">commonmark-hs</a>, which is the Haskell implementation of the <a href="https://commonmark.org/"><strong>CommonMark</strong> specification</a>, written by the same author of Pandoc. Another reason for switching is that commonmark-hs and its extensions can be compiled to JavaScript via GHCJS<span data-nosnippet=""><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup></span>, which is useful when reusing the Haskell code with the web app (see below).</p><div id="footnotes"><ol><li id="fn1"><p>See <span class="zettel-link-container cf"><span class="zettel-link" title="Zettel: Obelisk tutorial, Markdown preview with Reflex"><a href="obelisk-tutorial">Obelisk tutorial, Markdown preview with Reflex</a></span></span> for a description of the development workflow involving writing Haskell on the frontend.</p><a href="#fnref1">↩︎</a></li></ol></div></div></li><li class="item"><div class="pandoc"><p>See <span class="zettel-link-container cf"><span class="zettel-link" title="Zettel: Obelisk tutorial, Markdown preview with Reflex"><a href="obelisk-tutorial">Obelisk tutorial, Markdown preview with Reflex</a></span></span> for a description of the development workflow involving writing Haskell on the frontend.</p></div></li></ul></li><li><span class="zettel-link-container cf"><span class="zettel-link"><a href=".">Sridhar Ratnakumar</a></span></span><ul class="context-list" style="zoom: 85%;"></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">blog</span></div></nav><nav class="ui bottom attached icon compact inverted menu pink" id="neuron-nav-bar"><!--replace-start-9--><a class="item" href="." title="Home"><i class="home icon"></i></a><!--replace-end-9--><a class="item" href="https://github.com/srid/www.srid.ca/edit/master/./Obelisk tutorial, Markdown preview with Reflex.md" title="Edit this page"><i class="edit icon"></i></a><a class="right item" href="impulse" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.25.1" /></a></div></div></div></body></html>